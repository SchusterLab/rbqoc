"""
hrutil.py - This module exposes utility functions for hamiltonian parameter robustness
"""

import os

from filelock import FileLock, Timeout
import h5py
import matplotlib.pyplot as plt
import numpy as np
from qoc import evolve_schroedinger_discrete

COLOR_PALETTE = (
    "blue", "red", "green", "pink", "purple", "orange",
    "teal", "grey", "black", "cyan", "magenta", "brown",
    "azure", "beige", "coral", "crimson",
)

COLOR_PALETTE_LEN = len(COLOR_PALETTE)

def hamiltonian_args_sweep(evol_args, hamiltonian_args_set, pulse_path, suffix):
    """
    Given a set of hamiltonian_args, run evolve_schroedinger_discrete for a control pulse
    and save the error associated with each evolution to an h5 file.

    Arguments:
    evol_args :: dict(any) - The arguments to pass to evolve_schroedinger_discrete
        in addition to the hamiltonian_args and the control pulse
    hamiltonian_args_set :: ndarray(trial_count x hamiltonian_arg_count)
        - A list of the hamiltonian arguments that should be swept over.
    pulse_path :: list(str) - A list of paths to the output file
        of the pulse that should be evolved.
    suffix :: str - The suffix to append to the pulse_path that will
        constitute the new file where data from these evolutions is stored.

    Returns:
    save_path :: str - The destination of the file where the
        sweep information was saved
    """
    # Obtain the locks and full paths to the pulse and save files.
    pulse_path_lock = "{}.lock".format(pulse_path)
    # We assume that `pulse_path` is an h5 file with the suffix ".h5".
    save_path = "{}_{}.h5".format(pulse_path.split(".h5")[0], suffix)
    save_path_lock = "{}.lock".format(save_path)

    # Grab the control pulse that achieved the minimum error.
    try:
        with FileLock(pulse_path_lock):
            with h5py.File(pulse_path, "r") as pulse_file:
                index = np.argmin(pulse_file["error"])
                controls = pulse_file["controls"][index][()]
            #ENDWITH
        #ENDWITH
    except Timeout:
        print("Timeout when attempting to access {}".format(pulse_path_lock))
        exit(1)

    # Create the save file. Or use the existing sweep.
    sweep_exists = False
    trial_count = hamiltonian_args_set.shape[0]
    try:
        with FileLock(save_path_lock):
            if os.path.exists(save_path):
                sweep_exists = True
            else:
                with h5py.File(save_path, "w") as save_file:
                    save_file["hamiltonian_args"] = hamiltonian_args_set
                    save_file["error"] = np.zeros(trial_count, dtype=np.float64)
                #ENDWITH
        #ENDWITH
    except Timeout:
        print("Timeout when attempting to access {}".format(save_path_lock))
        exit(1)

    # For each hamiltonian_args array in hamiltonian_args_set,
    # record the optimization error in the save file.
    if not sweep_exists:
        for trial, hamiltonian_args in enumerate(hamiltonian_args_set):
            # Perform the evolution.
            result = evolve_schroedinger_discrete(**evol_args, controls=controls,
                                                  hamiltonian_args=hamiltonian_args)
            error = result.error

            # Save the optimization error of the evolution.
            try:
                with FileLock(save_path_lock):
                    with h5py.File(save_path, "a") as save_file:
                        save_file["error"][trial] = error
                    #ENDWITH
                #ENDWITH
            except Timeout:
                print("Timeout when attempting to access {}"
                      " on trial {}."
                      "".format(save_path_lock, trial))
        #ENDFOR
    #ENDIF

    return save_path

            
def plot_hamiltonian_args_sweep(out_path, sweep_path_list, arg_index=0,
                                dpi=1000,
                                title=None, x_label=None, y_label=None):
    """
    Given a list of files generated by `hamiltonian_args_sweep`, plot their error
    against one of the args in hamiltonian_args.

    Arguments:
    out_path :: str - The destination to save the plot file to.
    sweep_path_list :: list(str) - A list of full paths to the files that contain
        "hamiltonian_args_set" and "error" fields.

    arg_index :: int - The index into each hamiltonian_args array that is the hamiltonian argument
        on the x-axis.
    dpi :: int - The resolution of the image.
    title :: str - Title for the plot.
    x_label :: str - Label on the x-axis for the plot.
    y_label :: str - Label on the y-axis for the plot.

    Returns: nothing
    """
    # Access each sweep_path in sweep_path_list and grab the associated errors and hamiltonian_args that
    # it produced.
    sweep_errors = list()
    sweep_hamiltonian_arg_set = list()
    for sweep_path in sweep_path_list:
        sweep_path_lock = "{}.lock".format(sweep_path)
        try:
            with FileLock(sweep_path_lock):
                with h5py.File(sweep_path, "r") as sweep_file:
                    sweep_errors.append(sweep_file["error"][()])
                    sweep_hamiltonian_arg_set.append(sweep_file["hamiltonian_args"][:, arg_index])
                #ENDWITH
            #ENDWITH
        except Timeout:
            print("Timeout when attempting to access {}"
                  "".format(sweep_path_lock))

    # Plot the hamiltonian args and errors.
    plt.figure()
    # Plot each set of hamiltonian args and associated errors.
    for i, errors in enumerate(sweep_errors):
        hamiltonian_arg_set = sweep_hamiltonian_arg_set[i]
        plt.plot(hamiltonian_arg_set, errors, color=get_color(i))
    if title is not None:
        plt.title(title)
    if x_label is not None:
        plt.xlabel(x_label)
    if y_label is not None:
        plt.ylabel(y_label)
    plt.savefig(out_path, dpi=dpi)


def get_color(i):
    """
    Return a matplotlib color.
    
    Arguments:
    i :: int - The index into the COLOR_PALETTE
    
    Returns:
    color :: str - The corresponding color
    """
    return COLOR_PALETTE[i % COLOR_PALETTE_LEN]
